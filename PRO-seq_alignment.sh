#!/usr/bin/env bash

#====================
#====================

# shell script for PROseq reads alignment

	     
#====================
#====================

# Required:
					      
#1. appropriate bowtie2 index  (it has .bt2 ext) which can be generated by <bowtie-build infile outfile>. Infile is a comma-separated list of FASTA files containing the reference sequences for alignment and outfile is the basename of the index files to write. The reference genome should combine both the species of interest and the one used as a spike-in. Note: S2 cells were included in PRO-seq library preparation, but were not ultimately used for normalization. 			      
#2. prinseq-lite - can be downloaded from https://sourceforge.net/projects/prinseq/files/ (version 0.20.4)
#3. fastx_tools	 - can be downloaded from https://github.com/agordon/libgtextutils/archive/master.zip (version 0.0.14)      
#4. bowtie2 - can be installed with 'sudo apt install bowtie2' (version 2.3.4.1)
#5. bedtools - can be installed with 'sudo apt install bedtools' (version 2.26.0)
#6. samtools - can be installed with 'sudo apt install samtools' (version 1.7)
#7. cutadapt - can be installed with 'conda install -c bioconda cutadapt' (version 1.16)
#8. barcode_splitter - can be installed with 'pip install barcode_splitter' (version 0.18.2)
#9. barcode file for each fastq file. Is tab-delimited with sample name followed by barcode sequence. The name is beginning of the fastq file name, ending in '_bc.txt'
#10. bedgraphToBigwig - can be installed with 'conda install -c bioconda ucsc-bedgraphtobigwig'
#11. bigWigMerge v2
					      				              
#=============================================================================================
 
# Usage

#1. Place fastq files to be analyzed in the working directory.
#2. Make sure the Paths are correct.
#3. Edit the List; Put the names of the fastq files (without the .fastq ext) to be analyzed in the List within "", seperated by a space.  
#4. In order to save the terminal output in a log file, type <script log_align_PROseq_xxx.txt>. this will create a log file named log_align_PROseq_xxx.txt in the working directory which will save terminal output until it is terminated by pressing <control D> in the command line.
#5. When ready, run the shell script by typing: sh align_PROseq_xxx.sh

#=============================================================================================

#Paths
###note: hg38 bowtie2 index was downloaded from the bowtie2 manual website
###note: hg38 chromosome sizes downloaded from https://hgdownload-test.gi.ucsc.edu/goldenPath/hg38/bigZips/, took out ones that aren't on well-mapped chromosomes

genome='/home/emw97/Seq_utils/Genomes/hg38_dm6/hg38_dm6'
rRNA='/home/emw97/ER_workdir/Remove_rRNA/hg19_rRNA_bt2/hg19_rRNA'
expchrominfo="/home/emw97/Seq_utils/hg38.chrom.sizes_ref.txt"
prinseq_lite="/home/emw97/Seq_utils/prinseq-lite-0.20.4/prinseq-lite.pl"
bgToBigWig="/home/emw97/Seq_utils/bedGraphToBigWig"

file_names="
A549A_S21_R1_001
A549B_S22_R1_001
U2OSA_S23_R1_001
U2OSB_S24_R1_001
"

#Sample names
samples="
GR_A549_WT_0dex_A
GR_A549_WT_01dex_A
GR_A549_WT_100dex_A
GR_A549_dGOR_0dex_A
GR_A549_dGOR_01dex_A
GR_A549_dGOR_100dex_A
GR_A549_WT_0dex_B
GR_A549_WT_01dex_B
GR_A549_WT_100dex_B
GR_A549_dGOR_0dex_B
GR_A549_dGOR_01dex_B
GR_A549_dGOR_100dex_B
GR_U20S_WT_0dex_A
GR_U20S_WT_01dex_A
GR_U20S_WT_100dex_A
GR_U20S_dGOR_0dex_A
GR_U20S_dGOR_01dex_A
GR_U20S_dGOR_100dex_A
GR_U20S_WT_0dex_B
GR_U20S_WT_01dex_B
GR_U20S_WT_100dex_B
GR_U20S_dGOR_0dex_B
GR_U20S_dGOR_01dex_B
GR_U20S_dGOR_100dex_B
"

#Input length parameters
nmer=42 #reads trimmed to this many nt, includes the 6 nt of UMI that will later be trimmed
toCut=7 #where 5' end of read should be trimmed to remove the ePRO-seq adapter
umiLength=6 #this many nts are trimmed before aligning
exp_chro=$(awk '{print $1}' ${expchrominfo})



# Splitting PRO-seq libraries by their in-line barcodes, present in the 3' adapter
### using barcode_splitter to separate files by ePRO-seq barcode. Opens fastq file, splits based on barcode file (tab-delimited, sample name and bc sequence), --mismatches means allow 2 mismatches, --partial allows 2 missing nts
for name in ${file_names}
do 
	echo "Splitting barcodes"
	barcode_splitter --bcfile ${name%%.*}_bc.txt --mismatches 2 --idxread 1 --prefix GR_ --format fastq --gzipin ${name%%.*}.fastq.gz
	rm GR_unmatched-read-1.fastq
	rm GR_multimatched-read-1.fastq
done	



echo "Collapsing reads with perfect identity, then clipping and reverse complementing"
### removing PCR duplicates with prinseq_lite, requires perfect matches, outputting in fastq format
### then use cutadapt to 1) trim adapter (-a TGGAATTCTCGGGTGCCAAGG), 2) remove first 7 nucleotides (ePRO-seq adapter) (-cut), remove anything less than 15 nt (-m, added 6 more nt to account for UMI), trim to 36 nt (note: will remove 6 more nt during alignment to trim the UMI so that will equal 36) (--length)
### then take reverse complement for alignment

for sample in ${samples}
do 
	echo ${sample}
	perl $prinseq_lite -derep 1 -fastq ${sample%%.*}-read-1.fastq -out_format 3 -out_bad null -out_good stdout | cutadapt -a TGGAATTCTCGGGTGCCAAGG --cut 7 --length 42 -m 21 - | fastx_reverse_complement -o ${sample%%.*}_processed.fastq
	gzip ${sample%%.*}-read-1.fastq
	gzip ${sample%%.*}_processed.fastq
	done


echo "Aligning"
### First aligning to an rDNA genome to filter out rRNA-mapping reads. Unaligned reads are then aligned to a combined hg38-dm6 genome

for sample in ${samples}
	do 
	echo ${sample}
	echo "Removing rRNA"
	bowtie2 --end-to-end --trim5 $umiLength -x $rRNA -U ${sample%%.*}_processed.fastq.gz -S temp.sam --un-gz ${sample%%.*}_norRNA.fastq.gz
	echo "Aligning reads and removing multimappers"
	#align reads to combined genome -> filter low quality -> remove multimappers (sed code deletes all lines with 'XS:' pattern) -> return bam
	bowtie2 --end-to-end --sensitive --trim5 6 -x $genome -U ${sample%%.*}_norRNA.fastq.gz | awk '$2 != 4 {print}' | sed '/XS:/d' | samtools view -bS '-' | samtools sort '-' | bamToBed > ${sample%%.*}.bed

	echo "Separating out human reads"
	for chr in ${exp_chro}
		do 
		awk '$1=="'${chr}'" {print $0}' ${sample%%.*}.bed >> ${sample%%.*}_hg38.bed 
		done

	echo "Sorting bed"	
	sort -k 1,1 -k2,2n ${sample%%.*}_hg38.bed > ${sample%%.*}_hg38_sorted.bed
	rm ${sample%%.*}_hg38.bed
	
	#Generate non-nomalized Bedgraphs
	echo "Generating non-normalized Bedgraphs..."
	awk '$6 == "+"' ${sample%%.*}_hg38_sorted.bed | genomeCoverageBed -i stdin -3 -bg -g ${expchrominfo} > ${sample%%.*}_hg38_fwd.bedgraph 
	awk '$6 == "-"' ${sample%%.*}_hg38_sorted.bed | genomeCoverageBed -scale -1 -i stdin -3 -bg -g ${expchrominfo} > ${sample%%.*}_hg38_rev.bedgraph
	#Make BigWig

	${bgToBigWig} ${sample%%.*}_hg38_fwd.bedgraph $expchrominfo ${sample%%.*}_fwd.bw
	${bgToBigWig} ${sample%%.*}_hg38_rev.bedgraph $expchrominfo ${sample%%.*}_rev.bw

done

rm *.bedgraph

### Merging bigwig files to use with dREG
bigWigMerge *_fwd.bw GR_all_fwd.bedgraph
bigWigMerge -threshold=-10000000 *_rev.bw GR_all_rev.bedgraph
bigWigMerge GR_A549*fwd.bw GR_A549_fwd.bedgraph
bigWigMerge -threshold=-10000000 GR_A549*rev.bw GR_A549_rev.bedgraph
bigWigMerge GR_U20S*fwd.bw GR_U20S_fwd.bedgraph
bigWigMerge -threshold=-10000000 GR_U20S*rev.bw GR_U20S_rev.bedgraph
${bgToBigWig} GR_all_fwd.bedgraph $expchrominfo GR_all_fwd.bw
${bgToBigWig} GR_all_rev.bedgraph $expchrominfo GR_all_rev.bw
${bgToBigWig} GR_A549_fwd.bedgraph $expchrominfo GR_A549_fwd.bw
${bgToBigWig} GR_A549_rev.bedgraph $expchrominfo GR_A549_rev.bw
${bgToBigWig} GR_U20S_fwd.bedgraph $expchrominfo GR_U20S_fwd.bw
${bgToBigWig} GR_U20S_rev.bedgraph $expchrominfo GR_U20S_rev.bw

